{"name":"Alter","body":"Passing something like a blog post through many complex filters (Markdown, Liquid, regex, Nokogiri, etc) can get ugly and difficult to test and debug. Alter enforces structure and consistency by moving each filter to easy-to-write processor classes. It also keeps a handy history of all \"alterations\". The source is a mere 50 lines of code, so it should be easy to read and extend.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'alter'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install alter\r\n\r\n## Usage\r\n\r\nSuppose you are building a blog and you want to run posts through a number of filters when converting to HTML. You might run it through Liquid, then Markdown, then do some crazy Nokogiri stuff, then rewrite YouTube URLs to embedded videos, then sanitize, do some regex replaces, etc. And maybe you want to run it through only some filters in one area of the site, but all filters in other areas. This can quickly get ugly and disorganized.\r\n\r\nAlter gives you structure and consistency by passing text (or really anything) through easy to write processor classes. All you need to do is inherit from `Alter::Processor` and provide an `output` method.\r\n\r\n<pre lang=\"ruby\"><code>\r\nclass KumbayaProcessor &#60; Alter::Processor\r\n  def output\r\n    input.gsub(\"sucks\", \"is great\")\r\n  end\r\nend\r\n</code></pre>\r\n    \r\nYou will already have access to the `input` attribute. You are simply delivering the `output` based upon the `input`. To use the processor, you will first create a new Alter item which will setup that initial `input` value.\r\n\r\n<pre lang=\"ruby\"><code>\r\ntext = Alter::Item.new \"Your language sucks\"\r\n</code></pre>\r\n    \r\nNow you can run that item through the processor by passing the `KumbayaProcessor` class to the process method. The process method also accepts an array of processors.\r\n\r\n<pre lang=\"ruby\"><code>\r\ntext.process KumbayaProcessor\r\ntext.value\r\n# result: \"Your language is great\"\r\n</code></pre>\r\n\r\nCalling process returns the altered item. Items have the following attributes:\r\n\r\n- `value` - the current value of the item\r\n- `input` - the original input of the item\r\n- `options` - the original options passed to the item\r\n- `history` - a history of every item alteration\r\n    \r\nYou will also have access to any `options` passed to the processor. Here is a class making use of `options`.\r\n\r\n<pre lang=\"ruby\"><code>\r\nclass EligibilityProcessor &#60; Alter::Processor\r\n  def output\r\n    if options[:age] >= 35\r\n      input + \" and you could run for President\"\r\n    else\r\n      input + \" but you're too young to be President\"\r\n    end\r\n  end\r\nend\r\n\r\ntext = Alter::Item.new \"Your language sucks\", :age => 37\r\ntext.process [KumbayaProcessor, EligibilityProcessor]\r\ntext.value\r\n# result: \"Your language is great and you could run for President\"\r\n</code></pre>\r\n    \r\nYou can just as easily chain or separate these process calls. Options can also be passed to the process method if you only want them available to specific processors.\r\n\r\n<pre lang=\"ruby\"><code>\r\ntext = Alter::Item.new \"Your language sucks\"\r\ntext.process KumbayaProcessor\r\ntext.process EligibilityProcessor, :age => 33\r\ntext.value\r\n# result: \"Your language is great but you're too young to be President\"\r\n</code></pre>\r\n    \r\n### History\r\n\r\nAlter keeps a history of every \"alteration\" made to the original input and stores it in the `history` array.\r\n\r\n<pre lang=\"ruby\"><code>\r\npp text.history.collect {|h| {:processor => h.processor, :input => h.input, :output => h.output, :options => h.options, :meta => h.meta}}\r\n</code></pre>\r\n\r\n<pre lang=\"console\"><code>\r\nresult:  \r\n[{:processor=>KumbayaProcessor,\r\n  :input=>\"Your language sucks\",\r\n  :output=>\"Your language is great\",\r\n  :options=>{},\r\n  :meta=>nil},\r\n {:processor=>EligibilityProcessor,\r\n  :input=>\"Your language is great\",\r\n  :output=>\"Your language is great but you're too young to be President\",\r\n  :options=>{:age=>33},\r\n  :meta=>nil}]\r\n</code></pre>\r\n        \r\n### Metadata\r\n\r\nExtra metadata can be written to the history by providing a `meta` method in the processor class.\r\n\r\n<pre lang=\"ruby\"><code>\r\nclass UselessProcessor &#60; Alter::Processor\r\n  def meta\r\n    { \r\n      :random => \"This is so #{rand(1000)}\",\r\n      :data => \"This is so meta\"\r\n    }\r\n  end\r\nend\r\n</code></pre>\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Added some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","tagline":"Enforce structure by moving content filters to easy-to-write processor classes","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}